//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain
// The SmartSoft Toolchain has been developed by:
//  
// Service Robotics Research Center
// University of Applied Sciences Ulm
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// www.servicerobotik-ulm.de
//
// This file is generated once. Modify this file to your needs. 
// If you want the toolchain to re-generate this file, please 
// delete it before running the code generator.
//--------------------------------------------------------------------------
#include "LaserTask.hh"
#include "ComponentWebotsLidar.hh"

#include <iostream>
#include <cstdint>
#include <climits>

#include <webots/Device.hpp>
#include <webots/Node.hpp>


LaserTask::LaserTask(SmartACE::SmartComponent *comp) 
:	LaserTaskCore(comp)
{
	std::cout << "constructor LaserTask\n";
}
LaserTask::~LaserTask() 
{
	std::cout << "destructor LaserTask\n";
}



int LaserTask::on_entry()
{
	// do initialization procedures here, which are called once, each time the task is started
	// it is possible to return != 0 (e.g. when initialization fails) then the task is not executed further

	// assign this controller to the correct robot in Webots
	char *robotName = std::getenv("WEBOTS_ROBOT_NAME");
	if (!robotName) {
		std::cout  << "WEBOTS_ROBOT_NAME not defined" << std::endl;
		FILE *f = fopen("robotName.txt", "rb");
		if (!f) {
			std::cout  << "'robotName.txt' file not found." << std::endl;
			return -1;
		}
		char name[256];
		int ret = fscanf(f, "%[^\n]", name);
		if (ret == 0) {
			std::cout  << "First line of the 'robotName.txt' file is empty." << std::endl;
			return -1;
		}
		char environment[256] = "WEBOTS_ROBOT_NAME=";
		putenv(strcat(environment, name));
	}

	// create Robot Instance
	wb_robot = new webots::Robot();

	// Get timestep from the world
	wb_time_step = wb_robot->getBasicTimeStep();

	// Connects to the sensor from Webots
	webots::Device *wb_device = NULL;
	int lidar_index = 0;
	std::string lidar_name;

	for(int i=0; i<wb_robot->getNumberOfDevices(); i++) {
		wb_device = wb_robot->getDeviceByIndex(i);
		if (wb_device->getNodeType() == webots::Node::LIDAR) {
			std::cout << "Device #" << i << " called "<< wb_device->getName() << " is a Lidar." << std::endl;
			lidar_index = i;
			lidar_name = wb_device->getName();
		}
	}

	wb_lidar=wb_robot->getLidar(lidar_name);
	wb_lidar->enable(wb_time_step);
	wb_lidar->enablePointCloud();

	// Set Webots sensor's properties to SmartMDSD model
	// Useful doc: http://servicerobotik-ulm.de/drupal/doxygen/components_commrep/classCommBasicObjects_1_1CommMobileLaserScan.html
	scan_count = 0;
	wb_h_res = wb_lidar->getHorizontalResolution();
	num_valid_points = wb_lidar->getNumberOfPoints();
	scan.set_scan_size(num_valid_points);
	scan.set_scan_update_count(scan_count);
	scan.set_scan_integer_field_of_view(-wb_h_res*UNIT_FACTOR/2.0, wb_h_res*UNIT_FACTOR);
	scan.set_min_distance(wb_lidar->getMinRange()*M_TO_CM);
	scan.set_max_distance(wb_lidar->getMaxRange()*M_TO_CM);
	scan.set_scan_length_unit(MEASURE_UNIT);

	return 0;
}


int LaserTask::on_execute()
{
	// this method is called from an outside loop,
	// hence, NEVER use an infinite loop (like "while(1)") here inside!!!
	// also do not use blocking calls which do not result from smartsoft kernel
	
	//Controller Code that is in "while loop" if run from Simulator should be inside "if statement" below,
	//otherwise the values will not be updated
	if (wb_robot->step(wb_time_step) != -1) {

		// Time settings and update scan count
		timeval _receive_time;
		gettimeofday(&_receive_time, 0);
		scan.set_scan_time_stamp(CommBasicObjects::CommTimeStamp(_receive_time));
		scan.set_scan_update_count(scan_count);

		// Get sensor's values from Webots side
		const float *rangeImageVector;
		rangeImageVector = (const float *)(void *)wb_lidar->getRangeImage(); // in m

		// Pass sensor's values to SmartMDSD side
		for(unsigned int i=0; i<num_valid_points; ++i)
		{
			unsigned int dist = (unsigned int)(rangeImageVector[i]*100.0); // in cm due to LaserScanPoint structure definition
			scan.set_scan_index(i, i);
			scan.set_scan_integer_distance(i, dist); // in cm due to LaserScanPoint structure definition
		}
		scan.set_scan_valid(true);
	}

	// Send out laser scan through port
	laserServiceOutPut(scan);
	++scan_count;
	scan.set_scan_valid(false);

	// it is possible to return != 0 (e.g. when the task detects errors), then the outer loop breaks and the task stops
	return 0;
}


int LaserTask::on_exit()
{

	delete wb_robot;

	// use this method to clean-up resources which are initialized in on_entry() and needs to be freed before the on_execute() can be called again
	return 0;
}
