//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain
// The SmartSoft Toolchain has been developed by:
//
// Service Robotics Research Center
// University of Applied Sciences Ulm
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// www.servicewb_robotik-ulm.de
//
// This file is generated once. Modify this file to your needs.
// If you want the toolchain to re-generate this file, please
// delete it before running the code generator.
//--------------------------------------------------------------------------
#include "LaserTask.hh"
#include "ComponentWebotsLidarTest.hh"

#include <iostream>
#include <cstdint>
#include <climits>
//#include <string>
#include <webots/Device.hpp>
#include <webots/Node.hpp>


LaserTask::LaserTask(SmartACE::SmartComponent *comp)
:	LaserTaskCore(comp)
{
	std::cout << "constructor LaserTask\n";
}
LaserTask::~LaserTask()
{
	std::cout << "destructor LaserTask\n";
}


int LaserTask::on_entry()
{
	// do initialization procedures here, which are called once, each time the task is started
	// it is possible to return != 0 (e.g. when initialization fails) then the task is not executed further


	// create Robot Instance
	wb_robot = new webots::Robot();

	// Get timestep from the world
	wb_time_step = wb_robot->getBasicTimeStep();

	// Connects to the sensor from Webots
	webots::Device *wb_device = NULL;
	int lidar_index = 0;
	std::string lidar_name;

	for(int i=0; i<wb_robot->getNumberOfDevices(); i++) {
		wb_device = wb_robot->getDeviceByIndex(i);
		if (wb_device->getNodeType() == webots::Node::LIDAR) {
			std::cout << "Device #" << i << " called "<< wb_device->getName() << " is a Lidar." << std::endl;
			lidar_index = i;
			lidar_name = wb_device->getName();
		}
	}

	wb_lidar=wb_robot->getLidar(lidar_name);
	wb_lidar->enable(wb_time_step);
	wb_lidar->enablePointCloud();

	// Set Webots sensor's properties to CommMobileLaserScan model
	// Useful doc: http://servicerobotik-ulm.de/drupal/doxygen/components_commrep/classCommBasicObjects_1_1CommMobileLaserScan.html
	// --- Properties
	scan_count = 0;
	wb_h_res = wb_lidar->getHorizontalResolution();
	scan.set_scan_update_count(scan_count);
	scan.set_scan_integer_field_of_view(-wb_h_res*UNIT_FACTOR/2.0, wb_h_res*UNIT_FACTOR);
	scan.set_min_distance(wb_lidar->getMinRange()*M_TO_CM);
	scan.set_max_distance(wb_lidar->getMaxRange()*M_TO_CM);
	scan.set_scan_length_unit(MEASURE_UNIT);

	// --- Points
	num_valid_points = wb_lidar->getNumberOfPoints();
	scan.set_scan_size(num_valid_points);

	return 0;
}


int LaserTask::on_execute()
{
	// this method is called from an outside loop,
	// hence, NEVER use an infinite loop (like "while(1)") here inside!!!
	// also do not use blocking calls which do not result from smartsoft kernel

    //Controller Code that is in "while loop" if run from Simulator should be inside "if statement" below,
    //otherwise the values will not be updated
	if (wb_robot->step(wb_time_step) != -1) {

		// --- Time settings
		timeval _receive_time;
		gettimeofday(&_receive_time, 0);
		scan.set_scan_time_stamp(CommBasicObjects::CommTimeStamp(_receive_time));

		// Get sensor's values using the DomainModel
		scan.set_scan_update_count(scan_count);
		//unsigned int num_valid_points = wb_lidar->getNumberOfPoints();
		//scan.set_scan_size(num_valid_points);

		// Create an array of Lidar's values
		const float *rangeImageVector;
		rangeImageVector = (const float *)(void *)wb_lidar->getRangeImage(); // in m

		// Pass Lidar's values to CommMobileLaserScan
		for(unsigned int i=0; i<num_valid_points; ++i)
		{
			unsigned int dist = (unsigned int)(rangeImageVector[i]*100.0); // in cm due to LaserScanPoint structure definition
			scan.set_scan_index(i, i);
			scan.set_scan_integer_distance(i, dist); // in cm due to LaserScanPoint structure definition
			if(i%2==0)
				std::cout << "LID["<< i << "] dist: " << scan.get_scan_distance(i) << " - " << rangeImageVector[i] << std::endl;
		}
		scan.set_scan_valid(true);
	}

	// Send LaserScan out
    laserServiceOutPut(scan);
    ++scan_count;
    scan.set_scan_valid(false);

	// it is possible to return != 0 (e.g. when the task detects errors), then the outer loop breaks and the task stops
	return 0;
}


int LaserTask::on_exit()
{
	delete wb_robot;

	// use this method to clean-up resources which are initialized in on_entry() and needs to be freed before the on_execute() can be called again
	return 0;
}
