//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain
// The SmartSoft Toolchain has been developed by:
//
// Service Robotics Research Center
// University of Applied Sciences Ulm
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// www.servicerobotik-ulm.de
//
// This file is generated once. Modify this file to your needs.
// If you want the toolchain to re-generate this file, please
// delete it before running the code generator.
//--------------------------------------------------------------------------
#include "Robotino3Task.hh"
#include "ComponentWebotsRobotino3.hh"

#include <iostream>

#include <webots/Device.hpp>
#include <webots/Node.hpp>


Robotino3Task::Robotino3Task(SmartACE::SmartComponent *comp)
:	Robotino3TaskCore(comp)
{
	std::cout << "constructor Robotino3Task\n";
}
Robotino3Task::~Robotino3Task()
{
	std::cout << "destructor Robotino3Task\n";
}


double check_velocity(double speed, double max_speed){
	if(speed >  max_speed)  speed =  max_speed;
	if(speed < -max_speed)  speed = -max_speed;
	return speed;
}


int Robotino3Task::on_entry()
{
	// do initialization procedures here, which are called once, each time the task is started
	// it is possible to return != 0 (e.g. when initialization fails) then the task is not executed further

	// assign this controller to the correct robot in Webots
	char *robotName = std::getenv("WEBOTS_ROBOT_NAME");
	if (!robotName) {
		std::cout  << "WEBOTS_ROBOT_NAME not defined" << std::endl;
		FILE *f = fopen("robotName.txt", "rb");
		if (!f) {
			std::cout  << "'robotName.txt' file not found." << std::endl;
			return -1;
		}
		char name[256];
		int ret = fscanf(f, "%[^\n]", name);
		if (ret == 0) {
			std::cout  << "First line of the 'robotName.txt' file is empty." << std::endl;
			return -1;
		}
		char environment[256] = "WEBOTS_ROBOT_NAME=";
		putenv(strcat(environment, name));
	}

	// create Robot Instance
	webotsRobot = new webots::Robot();

	// get timestep from the world
	webotsTimeStep = webotsRobot->getBasicTimeStep();

	// set Motors (name from PROTO definition in Webots)
	webotsMotor0 = webotsRobot->getMotor("wheel0_joint");
	webotsMotor1 = webotsRobot->getMotor("wheel1_joint");
	webotsMotor2 = webotsRobot->getMotor("wheel2_joint");

	webotsMotor0->setPosition(INFINITY);
	webotsMotor1->setPosition(INFINITY);
	webotsMotor2->setPosition(INFINITY);

	webotsMotor0->setVelocity(0);
	webotsMotor1->setVelocity(0);
	webotsMotor2->setVelocity(0);

	motorMaxSpeed = webotsMotor0->getMaxVelocity(); // in rad/s

	return 0;
}


int Robotino3Task::on_execute()
{
	// this method is called from an outside loop,
	// hence, NEVER use an infinite loop (like "while(1)") here inside!!!
	// also do not use blocking calls which do not result from smartsoft kernel

	//std::cout << "Hello from Robotino3Task " << std::endl;

	double vX = 0.0;
	double vY = 0.0;
	double vW = 0.0;
	double vMotor0 = 0.0;
	double vMotor1 = 0.0;
	double vMotor2 = 0.0;

	// acquisition
	COMP->Robotino3Mutex.acquire();

	// get values from port
	vX = COMP->velX; // in m/s
	vY = COMP->velY; // in m/s
	vW = COMP->velW; // in rad/s

	std::cout << " " << std::endl;
	std::cout << "[Robotino-Task] Get data" << std::endl;
	std::cout << "vX : " << vX << std::endl;
	std::cout << "vY : " << vY << std::endl;
	std::cout << "vW : " << vW << std::endl;

	// set velocities in rad/s for motors and check limits
	// because of the orientation of the robot, vX and vY are inverted
	// conversion matrix from paper, section 4: http://ftp.itam.mx/pub/alfredo/ROBOCUP/SSLDocs/PapersTDPs/omnidrive.pdf

	// Test 1, se déplace vers la gauche
	//vMotor0 = check_velocity(-0.5*vY+0.866*vX+WHEEL_GAP*vW, motorMaxSpeed);
	//vMotor1 = check_velocity(-0.5*vY-0.866*vX+WHEEL_GAP*vW, motorMaxSpeed);
	//vMotor2 = check_velocity(     vY         +WHEEL_GAP*vW, motorMaxSpeed);

	// Test 2, se déplace en diagonal vers le haut à droite
	vMotor0 = check_velocity(-0.5*vX+0.866*vY+WHEEL_GAP*vW, motorMaxSpeed);
	vMotor1 = check_velocity(-0.5*vX-0.866*vY+WHEEL_GAP*vW, motorMaxSpeed);
	vMotor2 = check_velocity(     vX          +WHEEL_GAP*vW, motorMaxSpeed);

	std::cout << " " << std::endl;
	std::cout << "[Robotino-Task] Set speed" << std::endl;
	std::cout << "vMotor0 : " << vMotor0 << std::endl;
	std::cout << "vMotor1 : " << vMotor1 << std::endl;
	std::cout << "vMotor2 : " << vMotor2 << std::endl;

	// controller code that is in "while loop" if run from Simulator should be inside "if statement" below,
	// otherwise the values will not be updated
	if (webotsRobot->step(webotsTimeStep) != -1) {

		// Pass values to motors in Webots side
		webotsMotor0->setVelocity(vMotor0);
		webotsMotor1->setVelocity(vMotor1);
		webotsMotor2->setVelocity(vMotor2);
	}
	else
		return -1;

	// release
	COMP->Robotino3Mutex.release();

	// it is possible to return != 0 (e.g. when the task detects errors), then the outer loop breaks and the task stops
	return 0;
}


int Robotino3Task::on_exit()
{
	delete webotsRobot;

	// use this method to clean-up resources which are initialized in on_entry() and needs to be freed before the on_execute() can be called again
	return 0;
}
