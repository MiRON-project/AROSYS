//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain
// The SmartSoft Toolchain has been developed by:
//
// Service Robotics Research Center
// University of Applied Sciences Ulm
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// www.servicerobotik-ulm.de
//
// This file is generated once. Modify this file to your needs.
// If you want the toolchain to re-generate this file, please
// delete it before running the code generator.
//--------------------------------------------------------------------------
#include "Robotino3Task.hh"
#include "ComponentWebotsRobotino3.hh"

#include <iostream>

#include <webots/Device.hpp>
#include <webots/Node.hpp>


Robotino3Task::Robotino3Task(SmartACE::SmartComponent *comp)
:	Robotino3TaskCore(comp)
{
	std::cout << "constructor Robotino3Task\n";
}
Robotino3Task::~Robotino3Task()
{
	std::cout << "destructor Robotino3Task\n";
}


double check_velocity(double speed, double max_speed){
    if(speed >  max_speed)  speed  =  max_speed;
    if(speed < -max_speed)  speed  = -max_speed;
    return speed;
}


int Robotino3Task::on_entry()
{
	// do initialization procedures here, which are called once, each time the task is started
	// it is possible to return != 0 (e.g. when initialization fails) then the task is not executed further

	// assign this controller to the correct robot in Webots
	char *robotName = std::getenv("WEBOTS_ROBOT_NAME");
	if (!robotName) {
		std::cout  << "WEBOTS_ROBOT_NAME not defined" << std::endl;
		FILE *f = fopen("robotName.txt", "rb");
		if (!f) {
			std::cout  << "'robotName.txt' file not found." << std::endl;
			return -1;
		}
		char name[256];
		int ret = fscanf(f, "%[^\n]", name);
		if (ret == 0) {
			std::cout  << "First line of the 'robotName.txt' file is empty." << std::endl;
			return -1;
		}
		char environment[256] = "WEBOTS_ROBOT_NAME=";
		putenv(strcat(environment, name));
	}
	
	// create Robot Instance
	wb_robot = new webots::Robot();

	// Get timestep from the world
	wb_time_step = wb_robot->getBasicTimeStep();

	// set Motors (name from PROTO definition in Webots)
	wb_motor_0 = wb_robot->getMotor("wheel0_joint");
	wb_motor_1 = wb_robot->getMotor("wheel1_joint");
	wb_motor_2 = wb_robot->getMotor("wheel2_joint");

	wb_motor_0->setPosition(INFINITY);
	wb_motor_1->setPosition(INFINITY);
	wb_motor_2->setPosition(INFINITY);


	wb_motor_0->setVelocity(0);
	wb_motor_1->setVelocity(0);
	wb_motor_2->setVelocity(0);

	motor_max_speed = wb_motor_0->getMaxVelocity(); // in rad/s

	return 0;
}


int Robotino3Task::on_execute()
{
	// this method is called from an outside loop,
	// hence, NEVER use an infinite loop (like "while(1)") here inside!!!
	// also do not use blocking calls which do not result from smartsoft kernel

	//std::cout << "Hello from Robotino3Task " << std::endl;

	double v_x = 0.0;
	double v_y = 0.0;
	double v_w = 0.0;
	double v_motor_0 = 0.0;
	double v_motor_1 = 0.0;
	double v_motor_2 = 0.0;

	// Acquisition
	COMP->Robotino3Mutex.acquire();

	// Get values from port
	v_x = COMP->vel_X; // in m/s
	v_y = COMP->vel_Y; // in m/s
	v_w = COMP->vel_W; // in rad/s

	std::cout << " " << std::endl;
	std::cout << "[Robotino-Task] Get data" << std::endl;
	std::cout << "v_x : " << v_x << std::endl;
	std::cout << "v_y : " << v_y << std::endl;
	std::cout << "v_w : " << v_w << std::endl;

	// Set velocities in rad/s for motors and check limits
	// Because of the orientation of the robot, v_x and v_y are inverted
	// Conversion matrix from paper, section 4: http://ftp.itam.mx/pub/alfredo/ROBOCUP/SSLDocs/PapersTDPs/omnidrive.pdf
	// Test 1, se déplace vers la gauche
	//v_motor_0 = check_velocity(-0.5*v_y+0.866*v_x+WHEEL_GAP*v_w, motor_max_speed);
	//v_motor_1 = check_velocity(-0.5*v_y-0.866*v_x+WHEEL_GAP*v_w, motor_max_speed);
	//v_motor_2 = check_velocity(     v_y         +WHEEL_GAP*v_w, motor_max_speed);

	// Test 2, se déplace en diagonal vers le haut à droite
	v_motor_0 = check_velocity(-0.5*v_x+0.866*v_y+WHEEL_GAP*v_w, motor_max_speed);
	v_motor_1 = check_velocity(-0.5*v_x-0.866*v_y+WHEEL_GAP*v_w, motor_max_speed);
	v_motor_2 = check_velocity(     v_x          +WHEEL_GAP*v_w, motor_max_speed);

	std::cout << " " << std::endl;
	std::cout << "[Robotino-Task] Set speed" << std::endl;
	std::cout << "v_motor_0 : " << v_motor_0 << std::endl;
	std::cout << "v_motor_1 : " << v_motor_1 << std::endl;
	std::cout << "v_motor_2 : " << v_motor_2 << std::endl;

	//Controller Code that is in "while loop" if run from Simulator should be inside "if statement" below,
	//otherwise the values will not be updated
	if (wb_robot->step(wb_time_step) != -1) {

		// Pass values to motors in Webots side
		wb_motor_0->setVelocity(v_motor_0);
		wb_motor_1->setVelocity(v_motor_1);
		wb_motor_2->setVelocity(v_motor_2);
	}
	else
		return -1;

	// Release
	COMP->Robotino3Mutex.release();

	// it is possible to return != 0 (e.g. when the task detects errors), then the outer loop breaks and the task stops
	return 0;
}


int Robotino3Task::on_exit()
{

	delete wb_robot;

	// use this method to clean-up resources which are initialized in on_entry() and needs to be freed before the on_execute() can be called again
	return 0;
}
