//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain
// The SmartSoft Toolchain has been developed by:
//  
// Service Robotics Research Center
// University of Applied Sciences Ulm
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// www.servicerobotik-ulm.de
//
// This file is generated once. Modify this file to your needs. 
// If you want the toolchain to re-generate this file, please 
// delete it before running the code generator.
//--------------------------------------------------------------------------
#include "Robotino3Task.hh"
#include "ComponentWebotsRobotino3.hh"

#include <iostream>

#include <webots/Device.hpp>
#include <webots/Node.hpp>


Robotino3Task::Robotino3Task(SmartACE::SmartComponent *comp) 
:	Robotino3TaskCore(comp)
{
	std::cout << "constructor Robotino3Task\n";
}
Robotino3Task::~Robotino3Task() 
{
	std::cout << "destructor Robotino3Task\n";
}


double check_velocity(double speed, double max_speed){
    if(speed >  max_speed)  speed  =  max_speed;
    if(speed < -max_speed)  speed  = -max_speed;
    return speed;
}


int Robotino3Task::on_entry()
{
	// do initialization procedures here, which are called once, each time the task is started
	// it is possible to return != 0 (e.g. when initialization fails) then the task is not executed further

	// create Robot Instance
	wb_robot = new webots::Robot();

	// Get timestep from the world
	wb_time_step = wb_robot->getBasicTimeStep();

	// set Motors (name from PROTO definition in Webots)
	wb_motor_0 = wb_robot->getMotor("wheel0_joint");
	wb_motor_1 = wb_robot->getMotor("wheel1_joint");
	wb_motor_2 = wb_robot->getMotor("wheel2_joint");

	wb_motor_0->setPosition(INFINITY);
	wb_motor_1->setPosition(INFINITY);
	wb_motor_2->setPosition(INFINITY);


	wb_motor_0->setVelocity(0);
	wb_motor_1->setVelocity(0);
	wb_motor_2->setVelocity(0);

	motor_max_speed = wb_motor_0->getMaxVelocity(); // in rad/s

	return 0;
}


int Robotino3Task::on_execute()
{
	// this method is called from an outside loop,
	// hence, NEVER use an infinite loop (like "while(1)") here inside!!!
	// also do not use blocking calls which do not result from smartsoft kernel
	
	//std::cout << "Hello from Robotino3Task " << std::endl;

	double vx = 0.0;
	double vy = 0.0;
	double omega = 0.0;
	double vel_0 = 0.0;
	double vel_1 = 0.0;
	double vel_2 = 0.0;

	// Acquisition
	COMP->Robotino3Mutex.acquire();

	// Get values from port
	vx = COMP->vel_X;
	vy = COMP->vel_Y;
	omega = COMP->turnrate;

	// Set velocities in rad/s for motors and check limits
	// Because of the orientation of the robot, vx and vy are inverted
	// Conversion matrix from paper, section 4: http://ftp.itam.mx/pub/alfredo/ROBOCUP/SSLDocs/PapersTDPs/omnidrive.pdf
	// Test 1, se déplace vers la gauche
	vel_0 = check_velocity(-0.5*vy+0.866*vx+WHEEL_GAP*omega, motor_max_speed);
	vel_1 = check_velocity(-0.5*vy-0.866*vx+WHEEL_GAP*omega, motor_max_speed);
	vel_2 = check_velocity(vy+WHEEL_GAP*omega, motor_max_speed);

	// Test 2, se déplace en diagonal vers le haut à droite
	vel_0 = check_velocity(-0.5*vx+0.866*vy+WHEEL_GAP*omega, motor_max_speed);
	vel_1 = check_velocity(-0.5*vx-0.866*vy+WHEEL_GAP*omega, motor_max_speed);
	vel_2 = check_velocity(vx+WHEEL_GAP*omega, motor_max_speed);

	std::cout << " " << std::endl;
	std::cout << "vel_0 : " << vel_0 << std::endl;
	std::cout << "vel_1 : " << vel_1 << std::endl;
	std::cout << "vel_2 : " << vel_2 << std::endl;

	//Controller Code that is in "while loop" if run from Simulator should be inside "if statement" below,
	//otherwise the values will not be updated
	if (wb_robot->step(wb_time_step) != -1) {

		// Pass values to motors in Webots side
		wb_motor_0->setVelocity(vel_0);
		wb_motor_1->setVelocity(vel_1);
		wb_motor_2->setVelocity(vel_2);
	}

	// Release
	COMP->Robotino3Mutex.release();

	// it is possible to return != 0 (e.g. when the task detects errors), then the outer loop breaks and the task stops
	return 0;
}


int Robotino3Task::on_exit()
{

	delete wb_robot;

	// use this method to clean-up resources which are initialized in on_entry() and needs to be freed before the on_execute() can be called again
	return 0;
}
