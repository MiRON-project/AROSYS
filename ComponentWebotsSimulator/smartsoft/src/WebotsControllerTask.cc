//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain
// The SmartSoft Toolchain has been developed by:
//  
// Service Robotics Research Center
// University of Applied Sciences Ulm
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// www.servicerobotik-ulm.de
//
// This file is generated once. Modify this file to your needs. 
// If you want the toolchain to re-generate this file, please 
// delete it before running the code generator.
//--------------------------------------------------------------------------
#include "WebotsControllerTask.hh"
#include "ComponentWebotsSimulator.hh"

#include <iostream>

WebotsControllerTask::WebotsControllerTask(SmartACE::SmartComponent *comp) 
:	WebotsControllerTaskCore(comp)
{
	std::cout << "constructor WebotsControllerTask\n";
}
WebotsControllerTask::~WebotsControllerTask() 
{
	std::cout << "destructor WebotsControllerTask\n";
}



int WebotsControllerTask::on_entry()
{
	// do initialization procedures here, which are called once, each time the task is started
	// it is possible to return != 0 (e.g. when initialization fails) then the task is not executed further

	// create Robot Instance
	robot = new webots::Robot();

	// set Motors

	// TODO: Update this code to be more generic
	// int n_devices = wb_robot_get_number_of_devices();
	// int i;
	// for(i=0; i<n_devices; i++) {
	// 	WbDeviceTag tag = wb_robot_get_device_by_index(i);
	//
	//	const char *name = wb_device_get_name(tag);
	//	wbNodeType type = wb_device_get_node_type(tag);
	//
	//	// do something with the device
	//	printf("Device #%d name = %s\n", i, name);
	//
	//	if (type == WB_NODE_ROTATIONAL_MOTOR){
	//		// do something with the MOTOR
	// 		printf("Device #%d is a rotational motor\n", i);
	//	}
	// }
	// end of TODO

	leftMotor = robot->getMotor("left wheel");
	rightMotor = robot->getMotor("right wheel");

	leftMotor->setPosition(INFINITY);
	rightMotor->setPosition(INFINITY);

	leftMotor->setVelocity(0);
	rightMotor->setVelocity(0);

	return 0;
}

void checkVelocity(double& leftSpeed, double& rightSpeed){
    if(-leftSpeed > MAX_SPEED){leftSpeed = -MAX_SPEED;}
    if( leftSpeed > MAX_SPEED){leftSpeed =  MAX_SPEED;}

    if(-rightSpeed > MAX_SPEED){rightSpeed = -MAX_SPEED;}
    if( rightSpeed > MAX_SPEED){rightSpeed =  MAX_SPEED;}
}

double normalizeBaseVelocity(double joyNavVal,double max_speed=MAX_SPEED){
	joyNavVal=(joyNavVal*max_speed)/10;
	return joyNavVal;
}

int WebotsControllerTask::on_execute()
{
	// this method is called from an outside loop,
	// hence, NEVER use an infinite loop (like "while(1)") here inside!!!
	// also do not use blocking calls which do not result from smartsoft kernel
	
	std::cout << "Hello from WebotsControllerTask " << std::endl;

	double omega;
	double leftSpeed;
	double rightSpeed;


	COMP->WebotsMutex.acquire();

	// Acquisition
	omega     = COMP -> omega;
    leftSpeed = normalizeBaseVelocity(COMP -> velocityLeftWheel);

    // Set velocities and check limits
    rightSpeed = leftSpeed - omega;
    leftSpeed  = leftSpeed + omega;
    checkVelocity(leftSpeed,rightSpeed);

    //Controller Code that is in "while loop" if run from Simulator should be inside "if statement" below,
    //otherwise the values will not be updated
    if (robot->step(TIME_STEP) != -1) {

    	// pass values to motors
    	leftMotor  -> setVelocity(leftSpeed);
    	rightMotor -> setVelocity(rightSpeed);
    	std::cout  << "leftSpeed  : " << leftSpeed  << std::endl;
    	std::cout  << "rightSpeed : " << rightSpeed << std::endl;
    	std::cout  << "omega      : " << omega      << std::endl;

    }

    COMP->WebotsMutex.release();

	// it is possible to return != 0 (e.g. when the task detects errors), then the outer loop breaks and the task stops
	return 0;
}
int WebotsControllerTask::on_exit()
{
	delete robot;

	// use this method to clean-up resources which are initialized in on_entry() and needs to be freed before the on_execute() can be called again
	return 0;
}
