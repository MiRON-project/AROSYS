//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain
// The SmartSoft Toolchain has been developed by:
//
// Service Robotics Research Center
// University of Applied Sciences Ulm
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// www.servicerobotik-ulm.de
//
// This file is generated once. Modify this file to your needs.
// If you want the toolchain to re-generate this file, please
// delete it before running the code generator.
//--------------------------------------------------------------------------
#include "Pioneer3DXTask.hh"
#include "ComponentWebotsPioneer3DX.hh"

#include <iostream>

Pioneer3DXTask::Pioneer3DXTask(SmartACE::SmartComponent *comp)
:	Pioneer3DXTaskCore(comp)
{
  std::cout << "constructor Pioneer3DXTask\n";
}
Pioneer3DXTask::~Pioneer3DXTask()
{
  std::cout << "destructor Pioneer3DXTask\n";
}


void check_velocity(double& leftSpeed, double& rightSpeed, double max_speed){
  if(leftSpeed >  max_speed)  leftSpeed  =  max_speed;
  if(leftSpeed < -max_speed)  leftSpeed  = -max_speed;

  if(rightSpeed >  max_speed) rightSpeed =  max_speed;
  if(rightSpeed < -max_speed) rightSpeed = -max_speed;
}


int Pioneer3DXTask::on_entry()
{
  // do initialization procedures here, which are called once, each time the task is started
  // it is possible to return != 0 (e.g. when initialization fails) then the task is not executed further

  // assign this controller to the correct robot in Webots
  char *robotName = std::getenv("WEBOTS_ROBOT_NAME");
  if (!robotName) {
    std::cout  << "WEBOTS_ROBOT_NAME not defined" << std::endl;
    FILE *f = fopen("robotName.txt", "rb");
    if (!f) {
      std::cout  << "'robotName.txt' file not found." << std::endl;
      return -1;
    }
    char name[256];
    int ret = fscanf(f, "%[^\n]", name);
    if (ret == 0) {
      std::cout  << "First line of the 'robotName.txt' file is empty." << std::endl;
      return -1;
    }
    char environment[256] = "WEBOTS_ROBOT_NAME=";
    putenv(strcat(environment, name));
  }

  // create Robot Instance
  webotsRobot = new webots::Robot();

  // get timestep from the world
  webotsTimeStep = webotsRobot->getBasicTimeStep();

  // set Motors (name from PROTO definition in Webots)
  webotsLeftMotor  = webotsRobot->getMotor("left wheel");
  webotsRightMotor = webotsRobot->getMotor("right wheel");

  webotsLeftMotor ->setPosition(INFINITY);
  webotsRightMotor->setPosition(INFINITY);

  webotsLeftMotor ->setVelocity(0);
  webotsRightMotor->setVelocity(0);

  motorMaxSpeed = webotsLeftMotor->getMaxVelocity(); // in rad/s

  return 0;
}


int Pioneer3DXTask::on_execute()
{
  // this method is called from an outside loop,
  // hence, NEVER use an infinite loop (like "while(1)") here inside!!!
  // also do not use blocking calls which do not result from smartsoft kernel

  //std::cout << "Hello from PioneerTask " << std::endl;

  double speed = 0.0;
  double omega = 0.0;
  double leftSpeed  = 0.0;
  double rightSpeed = 0.0;

  // Acquisition
  COMP->PioneerMutex.acquire();

  // Get values from port
  speed = COMP->vX;
  omega = COMP->vW;

  // set velocities in rad/s for motors and check limits
  rightSpeed = (2.0*speed + omega*WHEEL_GAP)/(2.0*WHEEL_RADIUS);
  leftSpeed  = (2.0*speed - omega*WHEEL_GAP)/(2.0*WHEEL_RADIUS);
  check_velocity(leftSpeed, rightSpeed, motorMaxSpeed);

  // controller code that is in "while loop" if run from Simulator should be inside "if statement" below,
  // otherwise the values will not be updated
  if (webotsRobot->step(webotsTimeStep) != -1) {

    // Pass values to motors in Webots side
    webotsLeftMotor  -> setVelocity(leftSpeed);
    webotsRightMotor -> setVelocity(rightSpeed);
  }
  else
    return -1;

  // Release
  COMP->PioneerMutex.release();

  // it is possible to return != 0 (e.g. when the task detects errors), then the outer loop breaks and the task stops
  return 0;
}


int Pioneer3DXTask::on_exit()
{
  delete webotsRobot;

  // use this method to clean-up resources which are initialized in on_entry() and needs to be freed before the on_execute() can be called again
  return 0;
}
