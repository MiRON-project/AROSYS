//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain
// The SmartSoft Toolchain has been developed by:
//  
// Service Robotics Research Center
// University of Applied Sciences Ulm
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// www.servicerobotik-ulm.de
//
// This file is generated once. Modify this file to your needs. 
// If you want the toolchain to re-generate this file, please 
// delete it before running the code generator.
//--------------------------------------------------------------------------
#include "Pioneer3DXTask.hh"
#include "ComponentWebotsPioneer3DX.hh"

#include <iostream>

Pioneer3DXTask::Pioneer3DXTask(SmartACE::SmartComponent *comp) 
:	Pioneer3DXTaskCore(comp)
{
	std::cout << "constructor Pioneer3DXTask\n";
}
Pioneer3DXTask::~Pioneer3DXTask() 
{
	std::cout << "destructor Pioneer3DXTask\n";
}

void check_velocity(double& left_speed, double& right_speed, double max_speed){
    if(left_speed >  max_speed)  left_speed  =  max_speed;
    if(left_speed < -max_speed)  left_speed  = -max_speed;

    if(right_speed >  max_speed) right_speed =  max_speed;
    if(right_speed < -max_speed) right_speed = -max_speed;
}


int Pioneer3DXTask::on_entry()
{
	// do initialization procedures here, which are called once, each time the task is started
	// it is possible to return != 0 (e.g. when initialization fails) then the task is not executed further

  // assign this controller to the correct robot in Webots
	char *robotName = std::getenv("WEBOTS_ROBOT_NAME");
	if (!robotName) {
		std::cout  << "WEBOTS_ROBOT_NAME not defined" << std::endl;
		FILE *f = fopen("robotName.txt", "rb");
		if (!f) {
		  std::cout  << "'robotName.txt' file not found." << std::endl;
		  return -1;
		}
		char name[256];
		int ret = fscanf(f, "%[^\n]", name);
		if (ret == 0) {
		  std::cout  << "First line of the 'robotName.txt' file is empty." << std::endl;
		  return -1;
		}
		char environment[256] = "WEBOTS_ROBOT_NAME=";
		putenv(strcat(environment, name));
	}

	// create Robot Instance
	wb_robot = new webots::Robot();

	// Get timestep from the world
	wb_time_step = wb_robot->getBasicTimeStep();

	// set Motors (name from PROTO definition in Webots)
	wb_left_motor  = wb_robot->getMotor("left wheel");
	wb_right_motor = wb_robot->getMotor("right wheel");

	wb_left_motor ->setPosition(INFINITY);
	wb_right_motor->setPosition(INFINITY);

	wb_left_motor ->setVelocity(0);
	wb_right_motor->setVelocity(0);

	motor_max_speed = wb_left_motor->getMaxVelocity(); // in rad/s

	return 0;
}


int Pioneer3DXTask::on_execute()
{
	// this method is called from an outside loop,
	// hence, NEVER use an infinite loop (like "while(1)") here inside!!!
	// also do not use blocking calls which do not result from smartsoft kernel
	
	//std::cout << "Hello from PioneerTask " << std::endl;

	double speed = 0.0;
	double omega = 0.0;
	double left_speed  = 0.0;
	double right_speed = 0.0;

	// Acquisition
	COMP->PioneerMutex.acquire();

	// Get values from port
	speed = COMP->v_X;
	omega = COMP->v_W;

	std::cout  << " " << std::endl;
	std::cout  << "Pioneer get1:" << std::endl;
	std::cout  << "speed : " << speed  << std::endl;
	std::cout  << "omega : " << omega  << std::endl;

	// Set velocities in rad/s for motors and check limits
	right_speed = (2.0*speed + omega*WHEEL_GAP)/(2.0*WHEEL_RADIUS);
	left_speed  = (2.0*speed - omega*WHEEL_GAP)/(2.0*WHEEL_RADIUS);
	check_velocity(left_speed, right_speed, motor_max_speed);

	std::cout  << " " << std::endl;
	std::cout  << "Pioneer get2:" << std::endl;
	std::cout  << "left_speed  : " << left_speed  << std::endl;
	std::cout  << "right_speed : " << right_speed << std::endl;
	std::cout  << "omega       : " << omega       << std::endl;

	//Controller Code that is in "while loop" if run from Simulator should be inside "if statement" below,
	//otherwise the values will not be updated
	if (wb_robot->step(wb_time_step) != -1) {

		// Pass values to motors in Webots side
		wb_left_motor  -> setVelocity(left_speed);
		wb_right_motor -> setVelocity(right_speed);
	}

	// Release
	COMP->PioneerMutex.release();

	// it is possible to return != 0 (e.g. when the task detects errors), then the outer loop breaks and the task stops
	return 0;
}


int Pioneer3DXTask::on_exit()
{
	delete wb_robot;

	// use this method to clean-up resources which are initialized in on_entry() and needs to be freed before the on_execute() can be called again
	return 0;
}
